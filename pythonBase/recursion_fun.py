#!/usr/bin/env python3
# -*- coding: utf-8 -*-

#递归函数
print('递归函数')
print('在函数内部，可以调用其他函数，如果一个函数在内部调用自身本身，整个函数就是递归函数'
      '通俗点说就是：自己调用自己的函数')
# fact(n) = n! = 1*2*3*(n-1)*n=(n-1)!*n = fact(n-1)*n
# 即fact(n)可以表示为 n*fact(n-1),只有n=1时需要特殊处理

def fact(n):
    if n == 1:
        return 1
    return n * fact(n-1)

print(fact(1))
print(fact(3))

# 使用递归函数需要注意防止栈溢出，在计算机中，函数调用时通过栈（stack）这种数据结构实现的
# 每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧；
# 由于栈的大小不是无限的，所以 递归调用的次数过多，就会导致栈溢出，上面的例子可以打印 fact(1000)

# fact(1000)

print('解决递归调用栈溢出的方法是：尾递归 优化，事实上 尾递归和 循环的效果一样；'
      '所以把循环看成是一种特殊的尾递归函数也是可以的'
      '--------------------------------------------'
      '尾递归：在函数返回的时候，调用自身本身，并且 return语句不能包含表达式。'
      '这样编译器或者解释器就可以把尾递归做成优化，使递归本身无论调用多少次，'
      '都只占用一个栈帧，不会出现栈溢出的情况')

print('解决上面的返回不是尾递归，则需要把返回表达式改为尾递归（把结果传入递归函数）')

def fact1(n):
    return fact_item(n, 1)

def fact_item(num,product):
    if num == 1:
        return product
    return fact_item(num - 1, num * product)
print('可以看到 return fact_item(num - 1, num * product)返回递归函数本身，'
      'num - 1 和 num * product 在函数调用前就被计算，不影响函数调用')

print(fact1(5))

print('尾递归调用时，如果做了优化，栈不会增长，因此无论多少次调用也不会导致栈溢出'
      '遗憾的是，大多数编程语言没有针对尾递归做优化，python解释器也没有做优化，'
      '所以即使把上面的 fact1(n) 函数改为尾递归方式，也会导致栈溢出')

# 小结：使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出
#       针对尾递归优化的语言可以通过尾递归防止栈溢出。
#       尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环
#       python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题